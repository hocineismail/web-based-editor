import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { Node, Edge } from "reactflow";
import { CustomNodeData, ProcessStep, Sequence } from "../types/interfaces";
import { parseSteps } from "../utils/parseSteps";

interface SequenceState {
  sequence: Sequence;
  nodes: Node<CustomNodeData>[];
  edges: Edge[];
  type: "tree" | "graph";
  ready: boolean;
}

const initialState: SequenceState = {
  sequence: {
    Name: "",
    StartStepId: "",
    Steps: [],
  },
  ready: false,
  nodes: [],
  edges: [],
  type: "tree", // default type
};

const sequenceSlice = createSlice({
  name: "sequence",
  initialState,
  reducers: {
    setInitStep(
      state,
      action: PayloadAction<{
        module: string;
        func: string;
      }>
    ) {
      const newStepId = `root_${Date.now()}`;
      const newStep: ProcessStep = {
        StepType: 1,
        StepId: newStepId,
        Function: `${action.payload.module}/${action.payload.func}`,
        Transitions: [
          {
            result: "Succeeded",
            NextStepId: "Done", // Default transition to 'Done'
          },
        ],
      };
      state.sequence.StartStepId = newStepId;
      state.sequence.Steps.push(newStep);
      const { nodes, edges } = parseSteps(state.sequence.Steps, state.nodes);
      state.nodes = nodes;
      state.edges = edges;
    },
    setSequence(state, action: PayloadAction<Sequence>) {
      state.sequence = action.payload;
      state.ready = action.payload.Steps.length > 1;
      const { nodes, edges } = parseSteps(action.payload.Steps, state.nodes);
      state.nodes = nodes;
      state.edges = edges;
    },
    addStep(
      state,
      action: PayloadAction<{
        parentStepId: string;
        module: string;
        func: string;
        result: "Succeeded" | "Failed";
      }>
    ) {
      const newStepId = `step_${Date.now()}`;
      const newStep: ProcessStep = {
        StepType: 1,
        StepId: newStepId,
        Function: `${action.payload.module}/${action.payload.func}`,
        Transitions: [
          {
            result: "Succeeded",
            NextStepId: "Done", // Default transition to 'Done'
          },
        ],
      };

      if (state.type === "graph") {
        // Check if the function already exists
        const existingStep = state.sequence.Steps.find(
          (step) => "Function" in step && step.Function === newStep.Function
        );

        if (existingStep) {
          // Just create a connection
          const parentStep = state.sequence.Steps.find(
            (step) => step.StepId === action.payload.parentStepId
          );
          if (parentStep && "Transitions" in parentStep) {
            // Ensure there is only one Succeeded and one Failed transition
            const existingTransitionIndex = parentStep.Transitions.findIndex(
              (t) => t.result === action.payload.result
            );
            if (existingTransitionIndex > -1) {
              parentStep.Transitions[existingTransitionIndex].NextStepId =
                existingStep.StepId;
            } else {
              parentStep.Transitions.push({
                result: action.payload.result,
                NextStepId: existingStep.StepId,
              });
            }
          }
        } else {
          state.sequence.Steps.push(newStep);
          // Update the parent step to include a transition to the new step
          const parentStep = state.sequence.Steps.find(
            (step) => step.StepId === action.payload.parentStepId
          );
          if (parentStep && "Transitions" in parentStep) {
            // Ensure there is only one Succeeded and one Failed transition
            const existingTransitionIndex = parentStep.Transitions.findIndex(
              (t) => t.result === action.payload.result
            );
            if (existingTransitionIndex > -1) {
              parentStep.Transitions[existingTransitionIndex].NextStepId =
                newStepId;
            } else {
              parentStep.Transitions.push({
                result: action.payload.result,
                NextStepId: newStepId,
              });
            }
          }
        }
      } else {
        // tree
        state.sequence.Steps.push(newStep);
        state.ready = state.sequence.Steps.length > 1;
        // Update the parent step to include a transition to the new step
        const parentStep = state.sequence.Steps.find(
          (step) => step.StepId === action.payload.parentStepId
        );
        if (parentStep && "Transitions" in parentStep) {
          // Ensure there is only one Succeeded and one Failed transition
          const existingTransitionIndex = parentStep.Transitions.findIndex(
            (t) => t.result === action.payload.result
          );
          if (existingTransitionIndex > -1) {
            const deleteStepAndChildren = (stepId: string) => {
              const stepsToDelete: string[] = [stepId];
              const stepsStack: string[] = [stepId];

              while (stepsStack.length > 0) {
                const currentStepId = stepsStack.pop();
                const currentStep = state.sequence.Steps.find(
                  (step) => step.StepId === currentStepId
                );

                if (currentStep && "Transitions" in currentStep) {
                  currentStep.Transitions.forEach((transition) => {
                    if (transition.NextStepId !== "Done") {
                      stepsToDelete.push(transition.NextStepId);
                      stepsStack.push(transition.NextStepId);
                    }
                  });
                }
              }

              state.sequence.Steps = state.sequence.Steps.filter(
                (step) => !stepsToDelete.includes(step.StepId)
              );
            };

            // Only call the delete function if the step to delete is not "Done"
            let stepIdToDelete =
              parentStep.Transitions[existingTransitionIndex].NextStepId;
            if (stepIdToDelete !== "Done") {
              // Find the parent step of the target step
              state.sequence.Steps.forEach((step) => {
                if ("Transitions" in step) {
                  step.Transitions.forEach((transition) => {
                    if (transition.NextStepId === stepIdToDelete) {
                      transition.NextStepId = "Done";
                    }
                  });
                }
              });
              deleteStepAndChildren(stepIdToDelete);
            }
            parentStep.Transitions[existingTransitionIndex].NextStepId =
              newStepId;
          } else {
            parentStep.Transitions.push({
              result: action.payload.result,
              NextStepId: newStepId,
            });
          }
        }
      

      const { nodes, edges } = parseSteps(state.sequence.Steps, state.nodes);
      state.nodes = nodes;
      state.edges = edges;
    },
    updateNodePosition(
      state,
      action: PayloadAction<{ id: string; position: { x: number; y: number } }>
    ) {
      const node = state.nodes.find((node) => node.id === action.payload.id);
      if (node) {
        node.position = action.payload.position;
      }
    },
    deleteStep(state, action: PayloadAction<string>) {
      const stepIdToDelete = action.payload;
      if (state.type === "tree") {
        const deleteStepAndChildren = (stepId: string) => {
          const stepsToDelete: string[] = [stepId];
          const stepsStack: string[] = [stepId];

          while (stepsStack.length > 0) {
            const currentStepId = stepsStack.pop();
            const currentStep = state.sequence.Steps.find(
              (step) => step.StepId === currentStepId
            );

            if (currentStep && "Transitions" in currentStep) {
              currentStep.Transitions.forEach((transition) => {
                if (transition.NextStepId !== "Done") {
                  stepsToDelete.push(transition.NextStepId);
                  stepsStack.push(transition.NextStepId);
                }
              });
            }
          }

          state.sequence.Steps = state.sequence.Steps.filter(
            (step) => !stepsToDelete.includes(step.StepId)
          );
        };

        if (stepIdToDelete !== "Done") {
          state.sequence.Steps.forEach((step) => {
            if ("Transitions" in step) {
              step.Transitions.forEach((transition) => {
                if (transition.NextStepId === stepIdToDelete) {
                  transition.NextStepId = "Done";
                }
              });
            }
          });
          deleteStepAndChildren(stepIdToDelete);
        }
      } else {
        // graph
        state.sequence.Steps = state.sequence.Steps.filter(
          (step) => step.StepId !== stepIdToDelete
        );

        state.sequence.Steps.forEach((step) => {
          if ("Transitions" in step) {
            step.Transitions = step.Transitions.filter(
              (t) => t.NextStepId !== stepIdToDelete
            );
          }
        });

        const isStepUsedAsNext = (stepId: string) =>
          state.sequence.Steps.some((step) =>
            "Transitions" in step
              ? step.Transitions.some((t) => t.NextStepId === stepId)
              : false
          );

        if (!isStepUsedAsNext(stepIdToDelete)) {
          state.sequence.Steps.forEach((step) => {
            if ("Transitions" in step) {
              step.Transitions = step.Transitions.filter(
                (t) => t.NextStepId !== stepIdToDelete
              );
            }
          });
        }
      }

      const { nodes, edges } = parseSteps(state.sequence.Steps, state.nodes);
      state.nodes = nodes;
      state.edges = edges;
    },
    updateStepTransition(
      state,
      action: PayloadAction<{
        stepId: string;
        result: "Succeeded" | "Failed";
        nextStepId: string;
      }>
    ) {
      const { stepId, result, nextStepId } = action.payload;
      const step = state.sequence.Steps.find((s) => s.StepId === stepId);
      if (step && "Transitions" in step) {
        const transition = step.Transitions.find((t) => t.result === result);
        if (transition) {
          transition.NextStepId = nextStepId;
        } else {
          step.Transitions.push({ result, NextStepId: nextStepId });
        }
      }

      const { nodes, edges } = parseSteps(state.sequence.Steps, state.nodes);
      state.nodes = nodes;
      state.edges = edges;
    },
    setSequenceType(state, action: PayloadAction<"tree" | "graph">) {
      state.type = action.payload;
    },
  },
});

export const {
  setSequence,
  addStep,
  updateNodePosition,
  deleteStep,
  updateStepTransition,
  setSequenceType,
  setInitStep,
} = sequenceSlice.actions;
export default sequenceSlice.reducer;
